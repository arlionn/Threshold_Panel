<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="Threshold_Panel" needs-panel-data="true" minver="2021a" lives-in-subdir="true">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>2.2</version>
<date>2022-06-01</date>
<description>Panel threshold model of Hansen (JoE, 1999)</description>
<tags>C23</tags>
<help>
This package is an implementation of Bruce E. Hansen's panel-threshold model.

Reference:
&quot;Threshold effects in non-dynamic panels: Estimation, testing, and inference&quot;,
published in Journal of Econometrics 93 (1999) 345-368.
URL: http://www.ssc.wisc.edu/~bhansen/progs/joe_99.html



Public functions
=================

estimateTpm(endo, exo, rexo, thresh, opts[null])
-------------------------------------------------
Estimate the model.

Parameters:
endo         - series, endogenous series
exo          - list, regime-independent regressors
rexo         - list, regime-dependent exogenous (currently only single
               entry supported)
thresh       - series, threshold variable
opts         - bundle, Configure estimation parameters (optional)

Returns: Bundle comprising various information.


plotTpm(model, path[null])
---------------------------
Plot the evaluated thresholds.

Parameters:
model        - bundle, returned bundle from estimateTpm() function
path         - string, Directory where to store plots (optional). If not
               specified, plots appear immediately on screen. If specified,
               the figure(s) will be named &quot;ThresholdPanel_CI_No=X.png&quot;
               where X refers to the number of thresholds.

Returns: Nothing


Default model and estimation values
===================================
The following default parameters are set:

- nthresholds = 1:          Number of thresholds, default: 1
- with_timeeffects = TRUE:  Estimate model with time-effects, default: TRUE
- nquantiles = 200:         Number of quantiles to analyze, default: 200
- nboot = 299:              Number of bootstrap replications, default: 299
- trimming_values = vec({0.01, 0.01, 0.05}): Percentages to trim the
                                             sample start and end for each
                                             of max. three thresholds.
- alpha = 0.5:              Choose a rather high value if you want to
                            estimate the refinement coefficient values.
- confidence_level = 0.95:  Level of confidence for threshold estimates

The &quot;opts&quot; parameter bundle
============================
The user can pass various parameters to estimateTpm() to over-write the
default values listed above.
To do so, you simple pass a bundle where the key must match the name of
the parameter you want to replace by a specific value. See the sample script
for an illustration.


Items of the bundle returned after estimation by estimateTpm()
===============================================================
Apart from all parameters set (See section entitled &quot;Default model and
estimation values&quot;), many further information are returned:

N                - Number of cross-section units
T                - Number of  of valid (actually used) observations
NT               - N * T

beta_lin         - matrix, (1+k) by 1 vector of estimated coefficients of
                   linear benchmark model with intercept + k regressors
sehomo_lin       - matrix of OLS S.E. of estimated linear benchmark model
sehet_lin        - matrix of HAC-robust S.E. of estimated linear
                   benchmark model
beta_indep_Tx    - matrix, k by 1 of regime-independent coeff. for model
                   with x regimes
sehet_indep_Tx   - matrix of HAC-robust S.E. of reg.-indep. coeff. for
                   model with x regimes
sehomo_indep_Tx  - matrix of OLS S.E. of reg.-indep. coeff. for model
                   with x regimes
beta_dep_Tx	     - matrix, n by 1 of regime-dependent coeff. for model
                   with x regimes
sehet_dep_Tx     - matrix of HAC-robust S.E. of reg.-dep. coeff. for
                   model with x regimes
sehomo_dep_Tx    - matrix of OLS S.E. of reg.-dep. coeff. for model with
                   x regimes
qq               - matrix, vector of potential threshold values
rhats            - matrix of estimated thresholds for all threshold
                   models (see row names for more details)
lrstats          - matrix, qn by nthresh storing likelihood ratio
                   statistics all threshold values for each model
                   (refinement value if computed)
lrtest           - nr by 1 matrix holding the LR-test statistics for nr
                   threshold models
lrprob           - matrix, nr by 1 holding the bootstrap pvalues of the
                   LR-test for nr threshold models
lrcrit           - matrix, nr by 3 holding the bootstrap critical values:
                   (10pct ~ 5pct ~ 1pct) for nr threshold models
SSE              - matrix of SSEs of linear benchmark|single|double
                   threshold models
R2               - matrix, within R^2 of linear|single|double threshold
                   models (see row names)
DW               - matrix, Durbin-Watson test statistics of
                   linear|single|double threshold models
csdeptes         - matrix, test results on no cross-sectional dependence
                   (test ~ pvalue) for linear|single|double threshold models
sercorr          - matrix, test results on serial corr. (order 1)
                   (test ~ pvalue) for linear|single|double threshold models
hettest          - matrix, test results of no heteroskedasticity
                   (test~pvalue) for linear|single|double threshold models



CHANGELOG:
----------
2.2 (June 2022)
  - Fix mismatch in dimension when calling rnameset().
  - Make sure that coefficient estimates are printed.
  - Internal clean-up: Make use of the built-in serial correlation test
    (by Wooldridge) and get rid of the dependency of the
    &quot;wooldridge_test_serial&quot; package.
  - Increase version requirement to 2021a
2.1 (November 2021)
  - Replace both deprecated functions colnames() and rownames()
2.0 (March 2021)
  - Changed API: Rename function SETUP_THRESH() to estimateTpm() and change
    arguments.
  - Changed API: Rename function lrplot() by plotTpm() and change
    arguments.
  - Replace &quot;stop&quot; by errorif() function.
  - Fix bug in get_interaction_terms() function for constructing
    interaction terms.
  - Make use of hdprod() function for computing interaction terms;
    results in about +20% gain of speed.
  - Internal refactoring and re-formatting (about 5% gain of speed).
  - Update help file.
  - Improve print-out of tests (formatting)
  - Minimum required version is 2020b now.
1.1 (June 2018)
  - Drop &quot;lrcrit&quot; input for lrplot() -- USER must correct their code!
  - 10%/5%/1% critical values for the LR-test on threshold equality
  (h0: gamma=gamm0) are now plotted as in Hansen (1999)
  - minor improvements and fix of a potential bug in THRESH_SETUP()
1.0 (Dez. 2016)
  - Minor corrections
0.923 (Oct. 2016)
  - Total package revamp
  - Now using gretl's internal panel toolbox
0.922 (Mai 2016)
  - Add &quot;sse[qi]= $huge&quot;
0.921 (August 2015)
  - cleaning up the code
  - get rid of the seqa() function
0.92 (August 2015)
  - cleaning up the code
  - solve some bugs which let to collinearity issues
  - speeding-up by vectorizing stuff and using internal functions
  - fix bug in the resampling procedure to bootstrap the test statistics
</help>
<data-files count="1">
ThresholdPanel_data_joe99.gdt </data-files>
<gretl-function name="estimateTpm" type="bundle">
 <params count="5">
  <param name="endo" type="series" const="true"/>
  <param name="exo" type="list"/>
  <param name="rexo" type="list"/>
  <param name="thresh" type="series" const="true"/>
  <param name="Options" type="bundle" optional="true" const="true"/>
 </params>
<code>/* Public main function calling the estimation procedure. */
set warnings off
self = default_tpm_values()
if exists(Options)
  self = Options + self
endif
# Checks
errorif(self.alpha &lt; 0 || self.alpha &gt; 1, &quot;Ensure 0 &lt; 'alpha' &lt; 1.&quot;)
if nelem(rexo) &gt; 1
  printf &quot;\nWarning: Currently only a single regime-dependent variable \n                 can be defined in the list named rexo. Please, re-specify\n                 your model.\n&quot;
  flush
endif
errorif(self.nthresholds &lt; 1, &quot;Number of thresholds must be at least 1.&quot;)
errorif(self.nthresholds &gt; 2, &quot;Currently only a double threshold model is at maximum supported.&quot;)
self.trimming_values = vec(self.trimming_values)
errorif(rows(self.trimming_values) &lt; self.nthresholds, sprintf(&quot;The no. of threshold tests does not equal the no. of \n                    entries in matrix 'self.trimming_values'. Please correct this.&quot;))
# Add intercept later
exo -= const
rexo -= const
NT = $nobs
list Lall = endo exo rexo thresh
smpl Lall --balanced --no-missing # Make sure you have a balanced dataset
errorif(NT != $nobs, &quot;The panel data set is unbalanced.&quot;)
self.NT = $nobs        # N*T
self.N = self.NT / min(pnobs(endo)) # no. of cross-sectional units
self.T = $pd                  # number time periods (T)
strings names_regime_independent = defarray(&quot;Const&quot;) + varnames(exo)
strings names_regime_dependent = varnames(rexo)
nexo = nelem(exo)
nrexo = nelem(rexo)
n_features = nexo + nrexo + 1  # &quot;+1&quot; for the intercept
# Prepare matrices to store some stuf for bundle output
matrix lrtest = zeros(self.nthresholds, 1)
matrix lrprob = zeros(self.nthresholds, 1)    # lr-test prob values: M1|M2|M3
matrix lrcrit = zeros(self.nthresholds, 3)  # lr-test bootstrapped criticial values: (10 pct~5pct~1pct)
matrix SSE = zeros(1 + self.nthresholds, 1)
matrix R2 = zeros(1 + self.nthresholds, 1)
matrix DW = zeros(1 + self.nthresholds, 1)
matrix hettest = zeros(1 + self.nthresholds, 2)
matrix csdeptest = zeros(1 + self.nthresholds, 2)
matrix sercorr = zeros(1 + self.nthresholds, 2)
loop lreg=1..self.nthresholds -q
  # &quot;1 + &quot; refers to the intercept
  matrix beta_indep_T$lreg = zeros(1 + nexo, 1)
  matrix sehet_indep_T$lreg = zeros(1 + nexo, 1)
  matrix sehomo_indep_T$lreg = zeros(1 + nexo, 1)
endloop
loop lreg=1..self.nthresholds -q
  scalar nrexo = $lreg + 1
  matrix beta_dep_T$lreg = zeros(nrexo, 1)
  matrix sehet_dep_T$lreg = zeros(nrexo, 1)
  matrix sehomo_dep_T$lreg = zeros(nrexo, 1)
endloop
printf &quot;*******************************************************\n&quot;
printf &quot;Threshold Panel Dataset Details\n&quot;
printf &quot;Number of cross-sectional units \t %d\n&quot;, self.N
printf &quot;Number of years effectivel used \t %d\n&quot;, self.T
printf &quot;Total observations \t %d\n&quot;, self.NT
printf &quot;Number of quantiles evaluated \t %d\n&quot;, self.nquantiles
printf &quot;Confidence level  \t %.3f\n&quot;, self.confidence_level
printf &quot;\n&quot;
printf &quot;*******************************************************\n\n&quot;
# Set up the vector of potential thresholds
dd = values(thresh)     # all unique values of realizations
# self.trimming_values[i] = .01 --&gt; percentage to self.trimming_values before search
qnt1 = self.nquantiles * self.trimming_values[1]
scalar inc = 1 / self.nquantiles
matrix sq = self.trimming_values[1] + 1 / self.nquantiles * seq(0, (self.nquantiles -2 * qnt1 + 1) -1)'
qq1 = dd[floor(sq * rows(dd))]    # vector of quintile values
qn1 = rows(qq1)                   # number of quintiles
cc = -2 * ln((1 - sqrt(self.confidence_level)))
# ESTIMATE BASELINE LINEAR estimate_and_bootstrap
string strTF = (self.with_timeeffects == TRUE) ? &quot;--time-dummies&quot; : &quot;&quot;
# FE OLS S.E.
panel endo const exo rexo --fixed-effects @strTF --quiet
self.sehomo_lin = $stderr
# FE + HAC robust S.E.
set pcse off      # set pcse on=Beck-Katz S.E.
panel endo const exo rexo --fixed-effects --robust @strTF --quiet
bundle b = $model
SSE[1] = $ess
R2[1] = b.within_rsq
DW[1] = b.dw
series e = $uhat
self.beta_lin = $coeff
self.sehet_lin = $stderr
if self.with_timeeffects == TRUE
  self.beta_lin = self.beta_lin[1:n_features]
  self.sehomo_lin = self.sehomo_lin[1:n_features]
  self.sehet_lin = self.sehet_lin[1:n_features]
endif
# Model specification tests based on HAC robust FE
modtest --panel --silent
hettest[1,] = $test ~ $pvalue
modtest --xdepend --silent
csdeptest[1,] = $test ~ $pvalue
list L1 = const exo rexo
if self.with_timeeffects == TRUE
  genr timedum
  L1+=dt_*
endif
modtest --autocorr --silent
sercorr[1,] = $test ~ $pvalue
# PRINTOUT LINEAR estimate_and_bootstrap RESULTS
print_linear_model_estimates(self.beta_lin, self.sehet_lin, self.sehomo_lin, SSE[1], names_regime_independent, names_regime_dependent, self.with_timeeffects, R2[1], DW[1], hettest[1,], csdeptest[1,], sercorr[1,])
# Start threshold procedure
loop lreg=1..self.nthresholds -q    # Loop over specified # of max. thresholds
  # FIRST ITERATION:
  # Only for a double threshold model we run a refinement estimation
  # as in Hansen  (1999)
  if lreg == 1
    # Initial run assumes a zero threshold (updated/estimated later)
    # M1: (min~point~max) | M2: (min~point~max) | ...
    matrix rhats = zeros(self.nthresholds, 3)
    # Store likelihood ratio over potential thresholds for each model
    matrix lrstats = zeros(rows(qq1), self.nthresholds)
  else
    #string stmp = sprintf(&quot;%d&quot;, ($lreg-1)) # NOT USED
  endif
  printf &quot;\n*************************************\n&quot;
  printf &quot;\nThreshold Model with %d Threshold(s)\n&quot;, $lreg
  flush
  bundle b = estimate_and_bootstrap(rhats[lreg,2], self.trimming_values[lreg], self.nboot, self.nquantiles, qq1, cc, endo, exo, rexo, thresh, strTF)
  # Store information from b
  rhats[lreg,] = b.rhatCI
  matrix lrstats[1:rows(b.lrstat), lreg] = b.lrstat
  # bootstrap is done in first iteration phase
  matrix lrprob[lreg] = b.lrprob
  matrix lrtest[lreg] = b.lrtest
  matrix lrcrit[lreg,] = b.lrcrit
  SSE[1 + lreg] = b.sse
  R2[1 + lreg] = b.r2
  beta_indep_T$lreg = b.beta_regindep
  sehet_indep_T$lreg = b.sehet_regindep
  sehomo_indep_T$lreg = b.sehomo_regindep
  beta_dep_T$lreg = b.beta_regdep
  sehet_dep_T$lreg = b.sehet_regdep
  sehomo_dep_T$lreg = b.sehomo_regdep
  if lreg != 2
    # For lreg==2 we compute the tests for the refinement
    # estimation below
    DW[lreg+1] = b.dw
    hettest[lreg+1,] = b.hettest
    csdeptest[lreg+1,] = b.csdeptest
    sercorr[lreg+1,] = b.sercorr
  endif
  # Print Model
  if lreg == 1
    print_model_estimates(beta_indep_T$lreg, sehet_indep_T$lreg, sehomo_indep_T$lreg, beta_dep_T$lreg, sehet_dep_T$lreg, sehomo_dep_T$lreg, rhats[1:lreg,], SSE[1+lreg], lrtest[lreg], lrcrit[lreg,], lrprob[lreg], names_regime_independent, names_regime_dependent, $lreg, 1, self.trimming_values[lreg], R2[1+lreg], DW[1+lreg], hettest[lreg+1,], csdeptest[lreg+1,], sercorr[lreg+1,], self)
  endif
  /* SECOND ITERATION: Refinement estimate no bootstrapping needed,
  as critical values are already obtained in first iteration
  NOTE: For the moment, we run the refinement estimation only for
  the double threshold model as in Hansen (1999). */
  if lreg == 2 # THIS PART WORKS ONLY FOR THE DOUBLE THRESHOLD estimate_and_bootstrap currently
    # Re-estimate the 1st threshold by conditioning on the latest one
    bundle b = estimate_and_bootstrap(rhats[lreg,2], self.trimming_values[lreg], 0, self.nquantiles, qq1, cc, endo, exo, rexo, thresh, strTF)
    if lrprob[lreg] &lt;= self.alpha
      # Only now update using the refinement estimate
      # Refinement estimate of 1st threshold value
      rhats[(lreg - 1),] = b.rhatCI
      # update the 1st threshold estimates
      lrstats[1:rows(b.lrstat), (lreg - 1)] = b.lrstat
    endif
    beta_indep_T$lreg = b.beta_regindep
    sehet_indep_T$lreg = b.sehet_regindep
    sehomo_indep_T$lreg = b.sehomo_regindep
    beta_dep_T$lreg = b.beta_regdep
    sehet_dep_T$lreg = b.sehet_regdep
    sehomo_dep_T$lreg = b.sehomo_regdep
    DW[lreg+1] = b.dw
    hettest[lreg+1,] = b.hettest
    csdeptest[lreg+1,] = b.csdeptest
    sercorr[lreg+1,] = b.sercorr
    SSE[1+lreg] = b.sse
    R2[1+lreg] = b.r2
    print_model_estimates(beta_indep_T$lreg, sehet_indep_T$lreg, sehomo_indep_T$lreg, beta_dep_T$lreg, sehet_dep_T$lreg, sehomo_dep_T$lreg, rhats[1:lreg,], SSE[1+lreg], lrtest[lreg], lrcrit[lreg,], lrprob[lreg], names_regime_independent, names_regime_dependent, $lreg, 2, self.trimming_values[lreg], R2[1+lreg], DW[1+lreg], hettest[lreg+1,], csdeptest[lreg+1,], sercorr[lreg+1,], self)
  endif
  self.beta_indep_T$lreg = beta_indep_T$lreg
  self.sehet_indep_T$lreg = sehet_indep_T$lreg
  self.sehomo_indep_T$lreg = sehomo_indep_T$lreg
  self.beta_dep_T$lreg = beta_dep_T$lreg
  self.sehet_dep_T$lreg = sehet_dep_T$lreg
  self.sehomo_dep_T$lreg = sehomo_dep_T$lreg
  self.rhats = rhats
endloop
# BUNDLE elements for output
if self.nthresholds == 1
  strings row_labels = defarray(&quot;Linear Model&quot;, &quot;Single Threshold&quot;)
  strings row_labels_2 = defarray(&quot;Single Threshold&quot;)
elif self.nthresholds == 2
  strings row_labels = defarray(&quot;Linear Model&quot;, &quot;Single Threshold&quot;, &quot;Dual Threshold&quot;)
  strings row_labels_2 = defarray(&quot;Single Threshold&quot;, &quot;Dual Threshold&quot;)
elif self.nthresholds == 3
  strings row_labels = defarray(&quot;Linear Model&quot;, &quot;Single Threshold&quot;, &quot;Dual Threshold&quot;, &quot;Quad. Threshold&quot;)
  strings row_labels_2 = defarray(&quot;Single Threshold&quot;, &quot;Dual Threshold&quot;, &quot;Quad. Threshold&quot;)
endif
strings column_labels = defarray(&quot;Test stat.&quot;, &quot;Prob.&quot;)
rnameset(DW, row_labels)
cnameset(DW, &quot;DW&quot;)
self.DW = DW
rnameset(hettest, row_labels)
cnameset(hettest, column_labels)
self.hettest = hettest
rnameset(csdeptest, row_labels)
cnameset(csdeptest, column_labels)
self.csdeptest = csdeptest
rnameset(sercorr, row_labels)
cnameset(sercorr, column_labels)
self.sercorr = sercorr
rnameset(lrtest, row_labels_2)
rnameset(lrprob, row_labels_2)
rnameset(lrcrit, row_labels_2)
cnameset(lrcrit, &quot;90pct. 95pct. 99pct.&quot;)
rnameset(SSE, row_labels)
rnameset(SSE, row_labels)
self.lrstats = lrstats
self.lrtest = lrtest
self.lrprob = lrprob
self.lrcrit = lrcrit
self.qq = qq1
self.SSE = SSE
self.R2 = R2
return self
</code>
</gretl-function>
<gretl-function name="plotTpm" type="void">
 <params count="2">
  <param name="self" type="bundle" const="true">
<description>Return by estimateTpm()</description>
  </param>
  <param name="path" type="string" optional="true" const="true">
<description>Directory for storing plots</description>
  </param>
 </params>
<code>/* Plot thresholds estimation results plus confidence intervals.
Asymptotic distribution of threshold estimate. */
matrix lrstats = (self.lrstats .&lt; 1000) .* self.lrstats
nrows_qq = rows(self.qq)
# 10%, 5 and 1% critical value for H0: gamma=gamma_0
matrix cc = {6.53, 7.35, 10.59}
loop nplot=1..cols(lrstats) -q
  matrix mtmp = ones(nrows_qq, cols(cc)) .* cc
  matrix mplot = lrstats[,nplot] ~ mtmp ~ self.qq
  cnameset(mplot, &quot;LR-Ratio 90pct. 95pct. 99pct. self.qq&quot;)
  if exists(fname)
    string filename = sprintf(&quot;%s/ThresholdPanel_CI_No=%d.png&quot;, path, $nplot)
  else
    string filename = &quot;display&quot;
  endif
  plot mplot
    options with-lines fit=none single-yaxis
    #literal set term png font 'Helvetica,13'
    printf &quot;set title 'Confidence Interval Construction: %d Threshold Model' font 'serif,13'&quot;, cols(lrstats)
    printf &quot;set xlabel 'Threshold Parameter no. %d' font                    'Helvetica,13'&quot;, $nplot
    literal set key outside below font 'Helvetica,13' #top right
    literal set y2tics
    #literal set xtics out offset 0,-0.5      # Move xtics cloer to the x-axis
    literal set ytics out
    #2) put the border more to the background by applying it
    # only on the left and bottom part and put it and the tics in gray
    literal set style line 11 lc rgb &quot;#808080&quot; lt 1
    literal set border 3 back ls 11     # get rid of upper + left border
    literal set tics nomirror
    #add a slight grid to make it easier to follow the exact position of the curves
    literal set style line 12 lc rgb &quot;#808080&quot; lt 0 lw 1  # light grey color
    literal set grid back ls 12
    # Line Styles
    literal set for [i=1:5] linetype i dashtype i
    literal set linetype 1 lc rgb &quot;black&quot; lw 2.0
    literal set linetype 2 lc rgb &quot;black&quot; lw 2.0
    literal set linetype 3 lc rgb &quot;black&quot; lw 2.0
    literal set linetype 4 lc rgb &quot;black&quot; lw 2.0
  end plot --output=&quot;@filename&quot;
endloop
</code>
</gretl-function>
<gretl-function name="compute_optimal_threshold" type="matrix" private="1">
 <params count="9">
  <param name="endo" type="series" const="true"/>
  <param name="exo" type="list" const="true"/>
  <param name="rexo" type="list" const="true"/>
  <param name="thresh" type="series" const="true"/>
  <param name="strTF" type="string" const="true"/>
  <param name="threshold" type="matrix" const="true">
<description>Threshold values</description>
  </param>
  <param name="qq1" type="matrix" const="true"/>
  <param name="qn1" type="int"/>
  <param name="nquantiles" type="int"/>
 </params>
<code>/* Determine optimal threshold value. */
if maxc(threshold) == 0
  qq = qq1
  matrix rr = 0
else
  matrix rr = msortby(threshold, 1)
  qq = qqsel(qq1, vec(rr))
endif
sse = compute_sse_of_thresholds(endo, exo, rexo, thresh, strTF, qq, rr)
rihat = iminc(sse)'
return sse[rihat] | qq[rihat]
</code>
</gretl-function>
<gretl-function name="compute_sse_of_thresholds" type="matrix" private="1">
 <params count="7">
  <param name="endo" type="series" const="true"/>
  <param name="exo" type="list" const="true"/>
  <param name="rexo" type="list" const="true"/>
  <param name="thresh" type="series" const="true"/>
  <param name="strTF" type="string" const="true"/>
  <param name="q" type="matrix" const="true"/>
  <param name="r" type="matrix" const="true"/>
 </params>
<code>/* Estimate FE-model conditional on (eventually already) estimated
threshold(s) 'r' over all potential break points 'q', and store
the $ess' in a vector. */
matrix sse = zeros(rows(q), 1)
matrix mat_thresh = {thresh}
matrix mat_rexo = {rexo}
loop qi=1..rows(q) -q
  if r == 0
    matrix rr = q[qi]
  else
    matrix rr = r | q[qi]
  endif
  rr = msortby(rr, 1)
  list INT = null
  matrix mINT = get_interaction_terms(rr, mat_thresh, mat_rexo)
  loop i=1..cols(mINT) -q
    INT += genseries(sprintf(&quot;S%d&quot;, $i), mINT[,i])
  endloop
  panel endo const exo INT --fixed-effects @strTF --quiet
  sse[qi] = $ess
endloop
return sse
</code>
</gretl-function>
<gretl-function name="qqsel" type="matrix" private="1">
 <params count="2">
  <param name="q" type="matrix" const="true">
<description>Col. vector</description>
  </param>
  <param name="r" type="matrix" const="true">
<description>Col. vector</description>
  </param>
 </params>
<code>/* Throws away those values of q which are in r. The resulting vector
q will be smaller if in q some values coincide with values in r. */
C = sumr((q .= r )) - 1
return selifr(q, C)
</code>
</gretl-function>
<gretl-function name="get_interaction_terms" type="matrix" private="1">
 <params count="3">
  <param name="r" type="matrix"/>
  <param name="thresh" type="matrix" const="true"/>
  <param name="rexo" type="matrix" const="true"/>
 </params>
<code>/* Construct interaction term. */
matrix r = vec(r)
r = msortby(r, 1)
nr = rows(r)
matrix D = zeros(rows(thresh), (nr + 1))
# construct selection matrix
D[,1] = (thresh .&lt;= r[1])
if nr == 1
  D[,2] = !D[,1]
elif rows(r) == 2
  D[,2] = (thresh .&gt; r[1] &amp;&amp; thresh .&lt; r[2])
  D[,3] = !D[,1] &amp;&amp; !D[,2]
endif
return hdprod(D, rexo)
</code>
</gretl-function>
<gretl-function name="estimate_and_bootstrap" type="bundle" private="1">
 <params count="11">
  <param name="threshold_values" type="matrix" const="true"/>
  <param name="trimming_values" type="scalar"/>
  <param name="nboot" type="int"/>
  <param name="nquantiles" type="scalar"/>
  <param name="qq1" type="matrix" const="true"/>
  <param name="cc" type="scalar"/>
  <param name="endo" type="series" const="true"/>
  <param name="exo" type="list" const="true"/>
  <param name="rexo" type="list" const="true"/>
  <param name="thresh" type="series" const="true"/>
  <param name="strTF" type="string" const="true">
<description>Time effects</description>
  </param>
 </params>
<code>/* Do all the heavy lifting. */
set warnings off
bundle mout
nt = $nobs        # N*T
n = nt / min(pnobs(endo))     # no. of cross-sectional units
tt = nt / n                   # Effective no. oftime periods (tt)
scalar qn1 = rows(qq1)
scalar nexo = nelem(exo)
scalar nrexo = nelem(rexo)
if maxc(threshold_values) == 0              # Single threshold case
  qq = qq1
  matrix rr = 0             # rr are the fixed thresholds
else                          # Multiple threshold case
  matrix rr = msortby(threshold_values, 1)
  qq = qqsel(qq1, vec(rr))
endif
sse = compute_sse_of_thresholds(endo, exo, rexo, thresh, strTF, qq, rr)
rihat = iminc(sse)'
matrix rhat = qq[rihat]         # Estimated threshold value
matrix sse1 = sse[rihat]    # SSE conditional on newly determined threshold
lr = (sse/sse1- 1) * nt
rhats = selifr(qq, (lr .&lt; cc))          # For determination of CIs of rhat
mout.lrstat = lr
mout.sse = sse1
if maxc(threshold_values) != 0
  matrix rrr = msortby((rr|rhat), 1)
else
  matrix rrr = rhat             # rrr comprises rr and new rhat
endif
trrr = rrr'
mout.rhatCI = (minc(rhats)|rhat|maxc(rhats))'
# Construct the interaction terms
matrix mINT = get_interaction_terms(rrr, {thresh}, {rexo})
list INT = null
loop i=1..cols(mINT) -q
  series S$i = mINT[,i]
  INT+=S$i
endloop
# FE Model + OLS S.E.
panel endo 0 exo INT --fixed-effects @strTF --quiet
bundle b = $model
series e = $uhat
matrix beta = $coeff
matrix sehomo = $stderr
mout.sse = $ess
mout.r2 = b.within_rsq
mout.dw = b.dw
modtest --panel --silent
mout.hettest = $test ~ $pvalue
modtest --xdepend --silent
mout.csdeptest = $test ~ $pvalue
list L1 = const exo INT
if strTF==&quot;--time-dummies&quot;
  genr timedum
  L1+=dt_*
endif
modtest --autocorr --silent
mout.sercorr = $test ~ $pvalue
# FE Model + robust S.E.
panel endo 0 exo INT --fixed-effects --robust @strTF --quiet
matrix sehet = $stderr
# add t-val. (based on robust S.E.)
beta ~= (beta./sehet) ~ sehomo ~ sehet
bexo = beta[1:(nexo+1),]
l1 = 1 + (nexo + 1)
num = nelem(INT)
l2 = l1 + num - 1
brexo = beta[l1:l2,]
mout.beta_regindep = bexo[,1]
mout.sehet_regindep = bexo[,4]
mout.sehomo_regindep = bexo[,3]
mout.beta_regdep = brexo[,1]
mout.sehet_regdep = brexo[,4]
mout.sehomo_regdep = brexo[,3]
# BOOTSTRAP LR Test for threshold effect #
# H0: b1=b2
if nboot &gt; 0
  /* Construct the interaction terms but only using information on
  previously estimated thresholds rr. */
  if abs(maxc(rr)) &gt; 0
    matrix mINT = get_interaction_terms(rr, {thresh}, {rexo})
    list INT = null
    loop i=1..cols(mINT) -q
      series S$i = mINT[,i]
      INT += S$i
    endloop
  else
    list INT = rexo
  endif
  # Null model with previously determined thresholds (if any)
  panel endo 0 exo INT --fixed-effects @strTF --quiet
  series yp = $yhat
  series ehat = $uhat
  # SSE based on bootstrap sample and newly determined threshold
  matrix sse0 = $ess
  lrt = (sse0/sse1 - 1) * nt
  scalar j = 1
  counter = 1
  matrix stats = zeros(nboot, 1)
  list xlist0 = exo rexo
  loop while j &lt;= nboot -q
    series yb = yp + resample(ehat)   # Hansen's resample method
    # Null model w.o. any threshold
    panel yb 0 xlist0 --fixed-effects @strTF --quiet
    matrix sse0 = $ess
    # Alternative model with a single threshold.
    # Threshold will be estimated
    matrix mnull = zeros(1, 1)
    matrix mrestA = compute_optimal_threshold(yb, exo, rexo, thresh, strTF, mnull, qq1, qn1, nquantiles)
    matrix sse1 = mrestA[1]
    rhat_b = mrestA[2]
    rrr = rhat_b      # estimated threshold based on bootstrap sample
    # Search for additional thresholds and run the refinement estimation
    if abs(maxc(threshold_values)) &gt; 0
      loop jj=1..rows(threshold_values) -q
        matrix sse0 = sse1
        matrix mrestB = compute_optimal_threshold(yb, exo, rexo, thresh, strTF, rrr, self.trimming_values, qq1, qn1, nquantiles)
        matrix sse1 = mrestB[1]
        rhat_b = mrestB[2]
        rrr = rrr|rhat_b
      endloop
    endif
    stats[j] = (sse0/sse1 - 1) * nt   # test stat. for H0: b1=b2
    if j == 1
      printf &quot;\nBootstrap iterations of %d: \n&quot;,  nboot
      flush
    endif
    if counter == 10
      if j == 100 || j == 200 || j == 300 || j == 400 || j == 500 || j == 600 || j == 700 || j == 800
        printf &quot;\n&quot;
      else
        printf &quot; %d &quot;, j
      endif
      flush
      counter = 0
    endif
    if j == nboot
      printf &quot;\n\n&quot;
    endif
    counter++
    j++
  endloop
  crits = quantile(stats, 0.9) ~ quantile(stats, 0.95) ~ quantile(stats, 0.99)
  scalar pv = sum(stats .&gt; lrt) / nboot
  mout.lrtest = lrt
  mout.lrcrit = crits
  mout.lrprob = pv
endif
set warnings on
return mout
</code>
</gretl-function>
<gretl-function name="print_linear_model_estimates" type="void" private="1">
 <params count="12">
  <param name="beta_lin" type="matrix" const="true"/>
  <param name="sehet_lin" type="matrix" const="true"/>
  <param name="sehomo_lin" type="matrix" const="true"/>
  <param name="sse" type="matrix" const="true"/>
  <param name="names_regime_independent" type="strings" const="true"/>
  <param name="names_regime_dependent" type="strings" const="true"/>
  <param name="with_timeeffects" type="int"/>
  <param name="R2" type="scalar"/>
  <param name="DW" type="scalar"/>
  <param name="hettest" type="matrix" const="true"/>
  <param name="csdeptest" type="matrix" const="true"/>
  <param name="sercorr" type="matrix" const="true"/>
 </params>
<code>/* */
printf &quot;\n***********************************\n&quot;
if with_timeeffects == 0
  printf &quot;*	Linear Model  	 *\n&quot;
else
  printf &quot;* Linear Model with time effects\n&quot;
endif
printf &quot;***********************************\n&quot;
printf &quot;\nCoefficient Estimates\n&quot;
matrix mtmp = beta_lin ~ (beta_lin./sehet_lin) ~ sehomo_lin ~ sehet_lin
cnameset(mtmp, &quot;Coeff t-val(HAC) OLS_SE HAC_SE&quot;)
strings rowlabels = names_regime_independent + names_regime_dependent
rnameset(mtmp, rowlabels)
printf &quot;%12.4f\n&quot;, mtmp
printf &quot;* Sum of Squared Errors: \t%.4f\n&quot;, sse
printf &quot;* Within R^2: \t\t\t%.4f\n&quot;, R2
printf &quot;* Durbin-Watson: \t\t%.4f\n&quot;, DW
printf &quot;* Test on no serial correlation of order 1:\n&quot;
printf &quot;  Teststat = %3.4f \t Prob. = %3.4f\n&quot;, sercorr[1], sercorr[2]
printf &quot;* Test on homoskedasticity:\n&quot;
printf &quot;  Teststat = %3.4f \t Prob. = %3.4f\n&quot;, hettest[1], hettest[2]
printf &quot;* Test on no cross-sectional depend.:\n&quot;
printf &quot;  Teststat = %3.4f \t Prob. = %3.4f\n&quot;, csdeptest[1], csdeptest[2]
flush
printf &quot;*******************************************************************************\n&quot;
</code>
</gretl-function>
<gretl-function name="default_tpm_values" type="bundle" private="1">
<code>/* Set default values. */
bundle D
scalar D.nthresholds = 1
scalar D.with_timeeffects = TRUE
scalar D.nquantiles = 200   # Hansen (1999) qn=400
scalar D.nboot = 299
# Hansen (1999) trim_1=0.01, trim_2=0.01, trim_3=0.05
matrix D.trimming_values = vec({0.01, 0.01, 0.05})
# 0&lt;alpha&lt;1: Choose a rather high value if you want to estimate the refinement coefficient values
scalar D.alpha = 0.5
scalar D.confidence_level = 0.95  # Hansen (1999) confidence_level=0.95
return D
</code>
</gretl-function>
<gretl-function name="print_model_estimates" type="void" private="1">
 <params count="22">
  <param name="beta_indep" type="matrix" const="true"/>
  <param name="sehet_indep" type="matrix" const="true"/>
  <param name="sehomo_indep" type="matrix" const="true"/>
  <param name="beta_dep" type="matrix" const="true"/>
  <param name="sehet_dep" type="matrix" const="true"/>
  <param name="sehomo_dep" type="matrix" const="true"/>
  <param name="rhats" type="matrix" const="true"/>
  <param name="sse" type="matrix" const="true"/>
  <param name="lrt" type="matrix" const="true"/>
  <param name="lrcrits" type="matrix" const="true"/>
  <param name="lrprob" type="scalar"/>
  <param name="names_regime_independent" type="strings" const="true"/>
  <param name="names_regime_dependent" type="strings" const="true"/>
  <param name="lreg" type="int"/>
  <param name="iterat" type="int"/>
  <param name="trimming_value" type="scalar"/>
  <param name="R2" type="scalar"/>
  <param name="DW" type="scalar"/>
  <param name="hettest" type="matrix" const="true"/>
  <param name="csdeptest" type="matrix" const="true"/>
  <param name="sercorr" type="matrix" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* */
set warnings off
printf &quot;\n&quot;
string strTF = (self.with_timeeffects == TRUE) ? &quot;With Time Effects&quot; : &quot;&quot;
if lreg == 1
  printf &quot;*******************************************************************************\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Single Threshold Model  *\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;%s\n&quot;, strTF
  printf &quot;Threshold Estimate = %12.5f\n&quot;, rhats[lreg, 2]
  printf &quot;Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n&quot;, (self.confidence_level * 100), minr(rhats[lreg,]), maxr(rhats[lreg,])
elif lreg == 2
  printf &quot;*******************************************************************************\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Double Threshold Model *\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;%s\n&quot;, strTF
  if iterat == 1
    printf &quot;*** First Iteration ***\n&quot;
    printf &quot;\nFixed Threshold(s) = %12.5f\n&quot;, rhats[lreg-1,2]
    printf &quot;Threshold Estimate = %12.5f\n&quot;, rhats[lreg,2]
    printf &quot;Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n&quot;, (self.confidence_level * 100), minr(rhats[lreg,]), maxr(rhats[lreg,])
  else
    printf &quot;*** Second Iteration ***\n&quot;
    printf &quot;\nFixed Threshold(s) = %12.5f\n&quot;, rhats[lreg,2]
    printf &quot;Threshold Estimate = %12.5f\n&quot;, rhats[lreg-1,2]
    printf &quot;Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n&quot;, (self.confidence_level * 100), minr(rhats[lreg-1,]), maxr(rhats[lreg-1,])
  endif
elif lreg == 3
  printf &quot;*******************************************************************************\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Triple Threshold Model  *\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;%s\n&quot;, strTF
  printf &quot;Trimming Percentage \t %.3f&quot;, trimming_value
  printf &quot;\n&quot;
  if iterat == 1
    printf &quot;*** First Iteration ***\n&quot;
    printf &quot;\nFixed Threshold(s) = %12.5f\n&quot;, rhats[1:lreg-1,2]'
    printf &quot;Threshold Estimate = %12.5f\n&quot;, rhats[lreg,2]
    printf &quot;Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n&quot;, (self.confidence_level * 100), minr(rhats[lreg,]), maxr(rhats[lreg,])
  else
    printf &quot;*** Second Iteration ***\n&quot;
  endif
endif
printf &quot;Sum of Squared Errors: %12.5f\n&quot;, sse
printf &quot;Trimming Percentage = %12.3f\n&quot;, trimming_value
if iterat == 1
  printf &quot;LR-test statistics = %12.3f\n&quot;, lrt
  printf &quot;Number of bootstrap replications = %d\n&quot;, self.nboot
  printf &quot;Bootstrap p-value: \t %.3f\n&quot;, lrprob
  rnameset(lrcrits, &quot;10pct 5pct 1pct&quot;)
  printf &quot;Critical Values: \t 10pct.=%4.3f\t5pct.=%4.3f\t1pct.=%4.3f\n&quot;, lrcrits[1], lrcrits[2], lrcrits[3]
  printf &quot;*******************************************************************************\n&quot;
endif
printf &quot;Regime-dependent variable(s): &quot;
loop i=1..nelem(names_regime_dependent) -q
  printf &quot;%s &quot;, names_regime_dependent[i]
endloop
printf &quot;\n\nRegime-independent Coefficients\n&quot;
matrix mtmp = beta_indep ~ (beta_indep./sehet_indep) ~ sehomo_indep ~ sehet_indep
cnameset(mtmp, &quot;Coeff t-val(HAC) OLS_SE HAC_SE&quot;)
strings rowlabels = names_regime_independent
rnameset(mtmp, rowlabels)
printf &quot;%12.4f\n&quot;, mtmp
matrix rsorted = sort(rhats[,2])
printf &quot;Regime-dependent Coefficients\n&quot;
strings rowlabels = null
if lreg == 1      # single threshold
  loop i=1..nelem(names_regime_dependent) -q
    rowlabels += sprintf(&quot;%s*I*(Thresh&lt;=%.3f) &quot;, names_regime_dependent[i], rsorted)
    rowlabels += sprintf(&quot;%s*I*(Thresh&gt;%.3f) &quot;, names_regime_dependent[i], rsorted)
  endloop
elif lreg == 2      # double threshold
  loop i=1..nelem(names_regime_dependent) -q
    rowlabels += sprintf(&quot;%s*I*(Thresh&lt;=%.3f) &quot;, names_regime_dependent[i], rsorted[1])
    rowlabels += sprintf(&quot;%s*I*(%.3f&lt;Thresh&lt;=%.3f) &quot;, names_regime_dependent[i], rsorted[1], rsorted[2])
    rowlabels += sprintf(&quot;%s*I*(%.3f&lt;Thresh) &quot;, names_regime_dependent[i], rsorted[2])
  endloop
elif lreg == 3      # triple threshold -- not yet implemented!
  funcerr &quot;Triple threshold model is not supported. Abort.&quot;
endif
matrix mtmp = beta_dep ~ (beta_dep./sehet_dep) ~ sehomo_dep ~ sehet_dep
cnameset(mtmp, &quot;Coeff t-val(HAC) OLS_SE HAC_SE&quot;)
rnameset(mtmp, rowlabels)
printf &quot;%12.4f\n&quot;, mtmp
if lreg==2 &amp;&amp; iterat==1
else
  printf &quot;* Sum of Squared Errors: \t%.4f\n&quot;, sse
  printf &quot;* Within R^2: \t\t\t%.4f\n&quot;, R2
  printf &quot;* Durbin-Watson: \t\t%.4f\n&quot;, DW
  printf &quot;* Test on no serial correlation of order 1:\n&quot;
  printf &quot;  Teststat = %3.4f \t Prob. = %3.4f\n&quot;, sercorr[1],sercorr[2]
  printf &quot;* Test on homoskedasticity:\n&quot;
  printf &quot;  Teststat = %3.4f \t Prob. = %3.4f\n&quot;, hettest[1], hettest[2]
  printf &quot;* Test on no cross-sectional depend.:\n&quot;
  printf &quot;  Teststat = %3.4f \t Prob. = %3.4f\n&quot;, csdeptest[1], csdeptest[2]
  flush
  printf &quot;*******************************************************************************\n&quot;
endif
set warnings on
</code>
</gretl-function>
<sample-script>
set verbose off
clear

/* Replication of Hansen's results in Journal of Econometrics (1999)

 NOTE: Hansen doesn't exploit the whole dataset comprising
 14 time observations (one lost due to lags) but actually only 13 if one
 looks at his code. Hence, our results based on the full unrestricted
 dataset do not fully coincide!
*/

include Threshold_Panel.gfn
open ThresholdPanel_data_joe99.gdt --frompkg=Threshold_Panel

REPLICATE_HANSEN90 = 0  # =1: replicate Hansen's paper, =0: small sample


# Define a panel dataset + provide meaningful series names
setobs 15 1:1 --stacked-time-series
rename v1 inva
rename v2 vala
rename v3 cfa
rename v4 debta

# Set up the series of interest
series vala2 = vala^2
series vala3 = vala^3
series debtval = debta*vala
list exo = vala vala2 vala3 debta debtval
list exo1 = lags(1, exo)
list rexo = cfa
list rexo1 = lags(1, rexo)
series thresh = debta(-1)
list Lall = inva exo1 rexo1 thresh


if REPLICATE_HANSEN90 == 0
    # Shrink dataset for illustration purpose only
    smpl 1:01 8:15

    # Make sure you have a balanced dataset
    smpl Lall --balanced --no-missing

    # Run the procedure with values to minimize computation time
    bundle opts = _(nthresholds = 1,\
                    nboot = 99,\
                    nquantiles = 99)
    set stopwatch
    bundle Model = estimateTpm(inva, exo1, rexo1, thresh, opts)
    printf &quot;\n This took %.2f seconds\n&quot;, $stopwatch

    print Model         # print bundle output

    /* Plot the Likelihood Ratio test confidence interval jointly with the
    'no-rejection region' using the LR-statistic for tests on gamma. */
    plotTpm(Model)
endif


if REPLICATE_HANSEN90 != 0
    print &quot;Start replicating Hansen's 1999 results. Better get a coffee...&quot;

    # Make sure you have a balanced dataset
    smpl Lall --balanced --no-missing

    bundle opts = _(\
                    nthresholds = 2,\
                    nboot = 300,\
                    nquantiles = 400,\
                    confidence_level = 0.95,\
                    trimming_values = vec({0.01, 0.01, 0.05}),\
                    with_timeeffects = 1\
                    )

    set stopwatch
    bundle Hansen = estimateTpm(inva, exo1, rexo1, thresh, opts)
    printf &quot;\n This took %.2f seconds\n&quot;, $stopwatch
    print Hansen

    plotTpm(Hansen)
endif
</sample-script>
</gretl-function-package>
</gretl-functions>
