# private functions

function matrix R_EST (series endo,
      list exo,
      list rexo,
      series thresh,
      string strTF,
      matrix r "Vector of threshold values",
      scalar trim "Trimming percentage",
      matrix qq1,
      int qn1,
      int qn)
    if maxc(r) == 0
        qq = qq1
        matrix rr = 0
    else
        matrix rr = msortby(r,1)
        qq = qqsel(qq1,vec(rr))
    endif
    sse = THR_SSE(endo,exo,rexo,thresh,strTF,qq,rr)
    rihat = iminc(sse)'
    return sse[rihat] | qq[rihat]
end function

function matrix THR_SSE (series endo,
      list exo,
      list rexo,
      series thresh,
      string strTF,
      matrix q,
      matrix r)
    # This function estimates FE models
    # conditional on (eventually already)
    # estimated threshold(s) 'r' over all
    # potential break points 'q', and
    # stores the $ess' in a vector.
    matrix sse = zeros(rows(q),1)
    loop qi=1..rows(q) -q
        if r==0
            matrix rr = q[qi]
        else
            matrix rr = r|q[qi]
        endif
        rr = msortby(rr,1)
        nr = rows(rr)
        list INT = null
        matrix mINT = intvar(rr, {thresh}, {rexo})
        loop i=1..cols(mINT) -q
            series S$i = mINT[,i]
            INT+=S$i
        endloop
        /* DEPRECATED
           list D = null
           list INT = null
           if rows(rr)>1
           matrix dd =  (thresh .< rr')
           dd[,nr] = dd[,nr]-dd[,nr-1]
           loop j=1..nr -q
           series D$j = dd[,j]
           D += D$j
           endloop
           else
           series D1 = (thresh .< rr)
           D += D1
           endif
           INT  = D ^ rexo
        */
        panel endo const exo INT --fixed-effects @strTF --quiet
        sse[qi] = $ess
    endloop
    return sse
end function

function matrix qqsel (matrix q "Col. vector",
      matrix r "Col. vector")
    # Throws away those values of q which are in r
    # The resulting vector q will be smaller if in
    # q some values coincide with values in r.
    C = sumr((q.=r))-1
    return selifr(q,C)
end function

function matrix intvar (matrix r,
      matrix thresh,
      matrix rexo)
    # Construct interaction term
    matrix r = vec(r)
    r=msortby(r,1)
    nr = rows(r)
    T = rows(thresh)
    matrix D = zeros(T,nr+1)
    matrix INT = zeros(T,(cols(rexo)*(nr+1)))
    if nr==1
        D[,1] = (thresh .<= r[1])
        D[,2] = (thresh .> r[1])
    elif rows(r)==2
        D[,1] = (thresh .<= r[1])
        D[,2] = (thresh .> r[1] && thresh .< r[2])
        D[,3] = (thresh .> r[2])
    endif
    loop j=1..cols(rexo) -q
        loop k=1..cols(D) -q
            INT[,k+j-1] = D[,k].*rexo[,j]
        endloop
    endloop
    return INT
end function

function bundle MODEL (matrix r,
      scalar trim,
      int nrep,
      scalar qn,
      matrix qq1,
      scalar cc,
      series endo,
      list exo,
      list rexo,
      series thresh,
      string strTF "Time effects")
    set warnings off
    bundle mout
    nt = $nobs				# N*T
    n = nt/min(pnobs(endo))	# no. of cross-sectional units
    tt = nt/n				# Effective no. oftime periods (tt)
    scalar qn1 = rows(qq1)
    scalar nexo = nelem(exo)
    scalar nrexo = nelem(rexo)
    if maxc(r)==0						# Single threshold case
        qq = qq1        
        matrix rr = 0					# rr are the fixed thresholds
    else								# Multiple threshold case
        matrix rr = msortby(r,1)
        qq = qqsel(qq1,vec(rr))
    endif
    
    sse = THR_SSE(endo,exo,rexo,thresh,strTF,qq,rr)
    rihat = iminc(sse)'
    matrix rhat = qq[rihat]							# Estimated threshold value
    matrix sse1 = sse[rihat]						# SSE conditional on newly determined threshold
    lr = (sse/sse1- 1)*nt
    rhats = selifr(qq,(lr .< cc))					# For determination of CIs of rhat
    mout.lrstat = lr
    mout.sse = sse1
    if maxc(r) != 0
        matrix rrr = msortby((rr|rhat),1)
    else
        matrix rrr = rhat							# rrr comprises rr and new rhat
    endif
    trrr = rrr'
    mout.rhatCI = (minc(rhats)|rhat|maxc(rhats))'
    #--------------------------------
    # Construct the interaction terms
    #--------------------------------
    matrix mINT = intvar(rrr, {thresh}, {rexo})
    list INT = null
    loop i=1..cols(mINT) -q
        series S$i = mINT[,i]
        INT+=S$i
    endloop
    /*
       list D = null
       list INT = null
       if rows(rrr)==1
       series D1 = (thresh <= rrr[1])
       series D0 = (thresh > rrr[1])
       list D = D1 D0
       elif rows(rrr)==2
       series D1 = (thresh <= rrr[1])
       series D0 = (thresh > rrr[1] && thresh <= rrr[2])
       series D2 = (thresh > rrr[2])
       list D = D1 D0 D2
       endif
       list INT = null
       loop foreach j rexo -q
       loop foreach k D -q
       series $k_$j = $k * rexo.$j
       INT+=$k_$j
       endloop
       endloop
    */
    # FE Model + OLS S.E.
    panel endo 0 exo INT --fixed-effects @strTF --quiet
    bundle b = $model
    series e = $uhat
    matrix beta = $coeff
    matrix sehomo = $stderr
    mout.sse = $ess
    mout.r2 = b.within_rsq
    mout.dw = b.dw
    modtest --panel --silent
    mout.hettest = $test~$pvalue
    modtest --xdepend --silent
    mout.csdeptest = $test~$pvalue
    list L1 = const exo INT
    if strTF=="--time-dummies"
        genr timedum
        L1+=dt_*
    endif
    mwool = wooldridge_test_serial(endo,L1,0)
    mout.sercorr = mwool[2:]
    # FE Model + robust S.E.
    panel endo 0 exo INT --fixed-effects --robust @strTF --quiet
    matrix sehet = $stderr
    beta = beta~(beta./sehet)~sehomo~sehet				# add t-val. (based on robust S.E.)
    bexo = beta[1:(nexo+1),]
    l1 = 1+(nexo+1)
    num = nelem(INT)
    l2 = l1+num-1
    brexo = beta[l1:l2,]
    mout.beta_regindep = bexo[,1]
    mout.sehet_regindep = bexo[,4]
    mout.sehomo_regindep = bexo[,3]
    mout.beta_regdep = brexo[,1]
    mout.sehet_regdep = brexo[,4]
    mout.sehomo_regdep = brexo[,3]
    #-----------------------------------------
    # BOOTSTRAP LR Test for threshold effect #
    # H0: b1=b2
    #-----------------------------------------
    if nrep > 0
        #-----------------------------------
        # Construct the interaction terms
        # but only using information on
        # previously estimated thresholds rr
        #-----------------------------------
        if abs(maxc(rr))>0
            matrix mINT = intvar(rr, {thresh}, {rexo})
            list INT = null
            loop i=1..cols(mINT) -q
                series S$i = mINT[,i]
                INT+=S$i
            endloop
        else
            list INT = rexo
        endif
        /* OLD but works
           list Db = null
           list INTb = null
           if abs(maxc(rr))>0
           if rows(rr)==1
           series D1 = (thresh <= rr[1])
           series D0 = (thresh > rr[1])
           list Db = D1 D0
           elif rows(rr)==2
           series D1 = (thresh <= rr[1])
           series D0 = (thresh > rr[1] && thresh <= rr[2])
           series D2 = (thresh > rr[2])
           list Db = D1 D0 D2
           endif
           loop foreach j rexo -q
           loop foreach k Db -q
           series $k_$j = $k * rexo.$j
           INTb+=$k_$j
           endloop
           endloop
           else
           list INTb = rexo
           endif
        */
        # Null model with previously determined thresholds (if any)
        panel endo 0 exo INT --fixed-effects @strTF --quiet
        series yp = $yhat
        series ehat = $uhat
        matrix sse0 = $ess			# SSE based on bootstrap sample and newly determined threshold
        lrt = (sse0/sse1-1)*nt
        scalar j=1
        counter = 1
        matrix stats = zeros(nrep,1)
        list xlist0 = exo rexo
        loop while j <= nrep -q
            series yb = yp + resample(ehat) # Hansen's resample method
            # Null model w.o. any threshold
            panel yb 0 xlist0 --fixed-effects @strTF --quiet
            matrix sse0 = $ess
            # Alternative model with a single threshold
            # The threshold will be estimated
            matrix mnull = zeros(1,1)
            matrix mrestA = R_EST(yb,exo,rexo,thresh,strTF,mnull,trim,qq1,qn1,qn)
            matrix sse1 = mrestA[1]
            rhat_b = mrestA[2]
            rrr = rhat_b					# estimated threshold based on bootstrap sample
            # Search for additional thresholds and run the refinement estimation
            if abs(maxc(r))>0
                loop jj=1..rows(r) -q
                    matrix sse0 = sse1
                    matrix mrestB = R_EST(yb,exo,rexo,thresh,strTF,rrr,trim,qq1,qn1,qn)
                    matrix sse1 = mrestB[1]
                    rhat_b = mrestB[2]
                    rrr = rrr|rhat_b
                endloop
            endif
            stats[j] = (sse0/sse1-1)*nt	# test stat. for H0: b1=b2
            if j==1
                printf "\nBootstrap iterations of %d: \n", nrep
                flush
            endif
            if counter==10
                if j==100 || j==200 || j==300 || j==400 || j==500 || j==600 || j==700 || j==800
                    printf "\n"
                else
                    printf " %d ", j
                endif
                flush
                counter=0
            endif
            if j==nrep
                printf "\n"
                printf "\n"
            endif
            counter++
            j++
        endloop
        crits = quantile(stats,0.9)~quantile(stats,0.95)~quantile(stats,0.99)
        scalar pv = sum(stats.>lrt)/nrep
        mout.lrtest = lrt
        mout.lrcrit = crits
        mout.lrprob = pv
    endif
    set warnings on
    return mout
end function

function void printout (matrix beta_indep,
      matrix sehet_indep,
      matrix sehomo_indep,
      matrix beta_dep,
      matrix sehet_dep,
      matrix sehomo_dep,
      matrix rhats,
      matrix sse,
      matrix lrt,
      matrix lrcrits,
      scalar lrprob,
      int nrep,
      strings strEXO,
      strings strREXO,
      int lreg,
      int iterat,
      scalar trim,
      scalar R2,
      scalar DW,
      matrix hettest,
      matrix csdeptest,
      matrix sercorr,
      scalar TF,
      scalar conf_level)
    set warnings off
    printf "\n"
    if TF==1
        string strTF = "With Time Effects"
    else
        string strTF = ""
    endif
    if lreg==1
        printf "*******************************************************************************\n"
        printf "*************************\n"
        printf "Single Threshold Model  *\n"
        printf "*************************\n"
        printf "%s\n", strTF
        printf "Threshold Estimate = %12.5f\n", rhats[lreg,2]
        printf "Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n", conf_level*100,\
          minr(rhats[lreg,]), maxr(rhats[lreg,])
    elif lreg==2
        printf "*******************************************************************************\n"
        printf "*************************\n"
        printf "Double Threshold Model *\n"
        printf "*************************\n"
        printf "%s\n", strTF
        if iterat==1
            printf "*** First Iteration ***\n"
            printf "\nFixed Threshold(s) = %12.5f\n", rhats[lreg-1,2]
            printf "Threshold Estimate = %12.5f\n", rhats[lreg,2]
            printf "Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n", conf_level*100, \
              minr(rhats[lreg,]), maxr(rhats[lreg,])
        else
            printf "*** Second Iteration ***\n"
            printf "\nFixed Threshold(s) = %12.5f\n", rhats[lreg,2]
            printf "Threshold Estimate = %12.5f\n", rhats[lreg-1,2]
            printf "Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n", conf_level*100, \
              minr(rhats[lreg-1,]), maxr(rhats[lreg-1,])
        endif
    elif lreg==3
        printf "*******************************************************************************\n"
        printf "*************************\n"
        printf "Triple Threshold Model  *\n"
        printf "*************************\n"
        printf "%s\n", strTF
        printf "Trimming Percentage \t %.3f", trim
        printf "\n"
        if iterat==1
            printf "*** First Iteration ***\n"
            printf "\nFixed Threshold(s) = %12.5f\n", rhats[1:lreg-1,2]'
            printf "Threshold Estimate = %12.5f\n", rhats[lreg,2]
            printf "Confidence Region (%d pct): \t MIN: %4.5f \t MAX: %4.5f\n", conf_level*100, \
              minr(rhats[lreg,]), maxr(rhats[lreg,])
        else
            printf "*** Second Iteration ***\n"
        endif
    endif
    printf "Sum of Squared Errors: %12.5f\n", sse
    printf "Trimming Percentage = %12.3f\n", trim
    if iterat==1
        printf "LR-test statistics = %12.3f\n", lrt
        printf "Number of bootstrap replications = %d\n", nrep
        printf "Bootstrap p-value: \t %.3f\n", lrprob
        rownames(lrcrits, "10pct 5pct 1pct")
        printf "Critical Values: \t 10pct.=%4.3f\t5pct.=%4.3f\t1pct.=%4.3f\n", lrcrits[1], lrcrits[2], lrcrits[3]
        printf "*******************************************************************************\n"
    endif
    printf "Regime-dependent variable(s): "
    loop i=1..nelem(strREXO) -q
        printf "%s ", strREXO[i]
    endloop
    printf "\n"
    printf "\nRegime-independent Coefficients\n"
    matrix mtmp = beta_indep ~ (beta_indep./sehet_indep) ~ sehomo_indep ~ sehet_indep
    colnames(mtmp, "Coeff t-val(HAC) OLS_SE HAC_SE")
    strings rname = defarray("Const")
    rname += strEXO
    rownames(mtmp, rname)
    printf "%12.4f\n", mtmp
    matrix rsorted = sort(rhats[,2])
    printf "Regime-dependent Coefficients\n"
    strings rname = null
    if lreg == 1			# single threshold
        loop i=1..nelem(strREXO) -q
            sprintf S "%s*I*(Thresh<=%.3f) ", strREXO[i], rsorted
            rname += S
            sprintf S "%s*I*(Thresh>%.3f) ", strREXO[i], rsorted
            rname += S
        endloop
    elif lreg == 2 			# double threshold
        loop i=1..nelem(strREXO) -q
            sprintf S "%s*I*(Thresh<=%.3f) ", strREXO[i], rsorted[1]
            rname += S
            sprintf S "%s*I*(%.3f<Thresh<=%.3f) ", strREXO[i], rsorted[1], rsorted[2]
            rname += S
            sprintf S "%s*I*(%.3f<Thresh) ", strREXO[i], rsorted[2]
            rname += S
        endloop
    elif lreg == 3			# triple threshold -- not yet implemented!
    endif
    matrix mtmp = beta_dep ~ (beta_dep./sehet_dep) ~ sehomo_dep ~ sehet_dep
    colnames(mtmp, "Coeff t-val(HAC) OLS_SE HAC_SE")
    rownames(mtmp,rname)
    printf "%12.4f\n", mtmp
    if lreg==2 && iterat==1
    else
        printf "* Sum of Squared Errors: %11.4f\n", sse
        printf "* Within R^2: %18.4f\n", R2
        printf "* Durbin-Watson: %12.4f\n", DW
        printf "* Test on no serial correlation of order 1:\n"
        printf "  Teststat = %3.4f \t Prob. = %3.4f\n", sercorr[1],sercorr[2]
        printf "* Test on homoskedasticity:\n"
        printf "  Teststat = %3.4f \t Prob. = %3.4f\n", hettest[1], hettest[2]
        printf "* Test on no cross-sectional depend.:\n"
        printf "  Teststat = %3.4f \t Prob. = %3.4f\n", csdeptest[1], csdeptest[2]
        flush
        printf "*******************************************************************************\n"
    endif
    set warnings on
end function

function void linprintout (matrix beta_lin,
      matrix sehet_lin,
      matrix sehomo_lin,
      matrix sse,
      strings strEXO,
      strings strREXO,
      int TF,
      scalar R2,
      scalar DW,
      matrix hettest,
      matrix csdeptest,
      matrix sercorr)
    printf "\n"
    printf "***********************************\n"
    if TF==0
        printf "*	Linear Model  	 *\n"
    else
        printf "* Linear Model with time effects\n"
    endif
    printf "***********************************\n"
    printf "\nCoefficient Estimates\n"
    matrix mtmp = beta_lin ~ (beta_lin./sehet_lin) ~ sehomo_lin ~ sehet_lin
    colnames(mtmp, "Coeff t-val(HAC) OLS_SE HAC_SE")
    strings rname = defarray("Const")
    rname += strEXO
    rname += strREXO
    rownames(mtmp, rname)
    printf "%12.4f\n", mtmp
    printf "* Sum of Squared Errors: %11.4f\n", sse
    printf "* Within R^2: %11.4f\n", R2
    printf "* Durbin-Watson: %12.4f\n", DW
    printf "* Test on no serial correlation of order 1:\n"
    printf "  Teststat = %3.4f \t Prob. = %3.4f\n", sercorr[1],sercorr[2]
    printf "* Test on homoskedasticity:\n"
    printf "  Teststat = %3.4f \t Prob. = %3.4f\n", hettest[1], hettest[2]
    printf "* Test on no cross-sectional depend.:\n"
    printf "  Teststat = %3.4f \t Prob. = %3.4f\n", csdeptest[1], csdeptest[2]
    #printf "\n"
    flush
    printf "*******************************************************************************\n"
end function

# public functions

function bundle THRESH_SETUP (const series endo,
      const list exo,
      const list rexo,
      const series thresh,
      int nthresh[1:2:1] "Number of thresholds to test",
      int TF[0:1:0] "Time-effects: 0=NO, 1=YES",
      int qn[10::200] "Number of quantiles to examine",
      int nrep[20::399] "Number of bootstrap replications",
      matrix trim "percentage to trim data before search",
      scalar alpha[0.001:0.99:0.1] "Significance level of the threshold test before computing the refinement estimate",
      scalar conf_lev[0.01:0.99:0.95] "confidence level for threshold")
    set warnings off
    if nelem(rexo)>1
        printf "Sorry, but at the moment only a single regime-dependent variable \n           can be defined in the list named rexo. Please, re-specify your model.\n"
    endif
    if nthresh>2
        printf "Sorry, but at the moment only a double threshold model is\n           implemented at maximum. Please correct this."
        stop
    endif
    trim = vec(trim)
    if rows(trim)!=nthresh
        printf "The no. of thresholds tests does not equal the no. of \n           entries in matrix 'trim'. Please correct this."
        stop
    endif
    NT = $nobs
    list Lall = endo exo rexo thresh
    # Make sure you have a balanced dataset
    smpl Lall --balanced --no-missing
    NT2 = $nobs
    if NT!=NT2
        printf "You have provided an unbalanced panel. Hwoever, this \n           procedure is only valid in case of a balanced panel. Please correct this."
        stop
    endif
    bundle OUT
    #strY = varname(ltmp)
    strEXO = varnames(exo)
    strREXO = varnames(rexo)
    #strTHRESH = varname(thresh)
    nexo = nelem(exo)
    nrexo = nelem(rexo)
    #------------------------------------------------------
    # Prepare matrices to store some stuf for bundle output
    #------------------------------------------------------
    matrix lrtest = zeros(nthresh,1)
    matrix lrprob = zeros(nthresh,1)			# lr-test prob values: M1|M2|M3
    matrix lrcrit = zeros(nthresh,3)      		# lr-test bootstrapped criticial values: (10 pct~5pct~1pct)
    matrix SSE = zeros(1+nthresh,1)
    matrix R2 = zeros(1+nthresh,1)
    matrix DW = zeros(1+nthresh,1)
    matrix hettest = zeros(1+nthresh,2)
    matrix csdeptest = zeros(1+nthresh,2)
    matrix sercorr = zeros(1+nthresh,2)
    loop lreg=1..nthresh -q
        matrix beta_indep_T$lreg = zeros(1+nexo,1)	# "1+" refers to the intercept
        matrix sehet_indep_T$lreg = zeros(1+nexo,1)
        matrix sehomo_indep_T$lreg = zeros(1+nexo,1)
    endloop
    loop lreg=1..nthresh -q
        scalar nrexo = $lreg+1
        matrix beta_dep_T$lreg = zeros(nrexo,1)
        matrix sehet_dep_T$lreg = zeros(nrexo,1)
        matrix sehomo_dep_T$lreg = zeros(nrexo,1)
    endloop
    nt = $nobs				# N*T
    n = nt/min(pnobs(endo))	# no. of cross-sectional units
    tt = $pd #nt/n			# Effective no. oftime periods (tt)
    OUT.nt = nt
    OUT.n = n
    OUT.tt = tt
    printf "*******************************************************\n"
    printf "Threshold Panel Dataset Details\n"
    printf "Number of cross-sectional units \t %d\n", n
    printf "Number of years effectivel used \t %d\n", tt
    printf "Total observations \t %d\n", nt
    printf "Number of quantiles evaluated \t %d\n", qn
    printf "Confidence level  \t %.3f\n", conf_lev
    printf "\n"
    printf "*******************************************************\n"
    printf "\n"
    #----------------------
    # Set up the vector of
    # potential thresholds
    #----------------------    
    dd = values(thresh)			# all unique values of realizations    
    qnt1 = qn*trim[1]			# trim[i] = .01 --> percentage to trim before search
    scalar inc = 1/qn
    matrix sq = trim[1] + 1/qn*seq(0, (qn-2*qnt1+1)-1)'
    qq1 = dd[floor(sq*rows(dd))]		# vector of quintile values
    qn1 = rows(qq1)						# number of quintiles
    cc = -2*ln(1-sqrt(conf_lev))
    if TF==0
        string strTF = ""
    else
        string strTF = "--time-dummies"
    endif
    #--------------------------------
    # ESTIMATE BASELINE LINEAR MODEL
    #--------------------------------
    #-------------
    # FE OLS S.E.
    #-------------
    panel endo const exo rexo --fixed-effects @strTF --quiet
    OUT.sehomo_lin = $stderr
    #---------------------
    # FE + HAC robust S.E.
    #---------------------
    set pcse off			# set pcse on=Beck-Katz S.E.
    panel endo const exo rexo --fixed-effects --robust @strTF --quiet
    bundle b = $model
    SSE[1]=$ess
    R2[1]=b.within_rsq
    DW[1] = b.dw
    series e = $uhat
    OUT.beta_lin = $coeff
    OUT.sehet_lin = $stderr
    if TF==1
        OUT.beta_lin = OUT.beta_lin[1:(nexo+nrexo-1)]
        OUT.sehomo_lin = OUT.sehomo_lin[1:(nexo+nrexo-1)]
        OUT.sehet_lin = OUT.sehet_lin[1:(nexo+nrexo-1)]
    endif
    #--------------------------
    # Model specification tests
    # based on HAC robust FE
    #--------------------------
    modtest --panel --silent
    hettest[1,] = $test~$pvalue
    modtest --xdepend --silent
    csdeptest[1,] = $test~$pvalue
    list L1 = const exo rexo
    if TF==1
        genr timedum
        L1+=dt_*
    endif
    mwool = wooldridge_test_serial(endo,L1,0)
    sercorr[1,] = mwool[2:]
    #------------------------------
    # PRINTOUT LINEAR MODEL RESULTS
    #------------------------------
    linprintout(OUT.beta_lin, OUT.sehet_lin, OUT.sehomo_lin, SSE[1], strEXO,\
      strREXO, TF, R2[1], DW[1], hettest[1,], csdeptest[1,], sercorr[1,])
    #--------------------------
    # Start threshold procedure
    #--------------------------
    loop lreg=1..nthresh -q		# Loop over specified # of max. thresholds

        #----------------------------------
        # FIRST ITERATION
        # Only for a double threshold model
        # we run a refinement estimation as
        # in Hansen  (1999)
        #-----------------------------------
        if lreg==1
            # Initial run assumes a zero threshold (updated/estimated later)
            matrix rhats = zeros(nthresh,3)				# M1: (min~point~max) | M2: (min~point~max) | ...
            matrix lrstats = zeros(rows(qq1),nthresh)	# Store likelihood ratio over potential thresholds for each model
        else
            sprintf stmp "%d", ($lreg-1)
        endif
        printf "\n*************************************\n"
        printf "\nThreshold Model with %d Threshold(s)\n", $lreg
        flush
        bundle b = MODEL(rhats[lreg,2],trim[lreg], nrep, qn, qq1, cc, endo,exo,rexo,thresh,strTF)        
        #-------------------------
        # Store information from b
        #-------------------------
        rhats[lreg,] = b.rhatCI
        matrix lrstats[1:rows(b.lrstat),lreg] = b.lrstat
        matrix lrprob[lreg] = b.lrprob					# bootstrap is done in first iteration phase
        matrix lrtest[lreg] = b.lrtest
        matrix lrcrit[lreg,] = b.lrcrit
        SSE[1+lreg] = b.sse
        R2[1+lreg] = b.r2
        beta_indep_T$lreg = b.beta_regindep
        sehet_indep_T$lreg = b.sehet_regindep
        sehomo_indep_T$lreg = b.sehomo_regindep
        beta_dep_T$lreg = b.beta_regdep
        sehet_dep_T$lreg = b.sehet_regdep
        sehomo_dep_T$lreg = b.sehomo_regdep
        if lreg!=2	# For lreg==2 we compute the tests for the refinement estimation below
            DW[lreg+1] = b.dw
            hettest[lreg+1,] = b.hettest
            csdeptest[lreg+1,] = b.csdeptest
            sercorr[lreg+1,] = b.sercorr
        endif
        #------------
        # Print Model
        #------------
        printout(beta_indep_T$lreg, sehet_indep_T$lreg, sehomo_indep_T$lreg, \
          beta_dep_T$lreg, sehet_dep_T$lreg, sehomo_dep_T$lreg, rhats[1:lreg,], \
          SSE[1+lreg], lrtest[lreg], lrcrit[lreg,], lrprob[lreg], nrep, strEXO, \
          strREXO, $lreg, 1, trim[lreg], R2[1+lreg], DW[1+lreg], hettest[lreg+1,], \
          csdeptest[lreg+1,], sercorr[lreg+1,], TF, conf_lev)
        #---------------------------------------
        # SECOND ITERATION: Refinement estimate
        #---------------------------------------
        # no bootstrapping needed, as critical
        # values are already obtained in first iteration
        # NOTE: For the moment, we run the refinement estimation
        # only for the double threshold model as in Hansen (1999).
        if lreg ==2 # TODO: THIS PART WORKS ONLY FOR THE DOUBLE THRES. MODEL ATM!
            #matrix rhattmp = rhats[lreg,2]	# Re-estimate the 1st threshold by conditioning on the latest one
            # Re-estimate the 1st threshold by conditioning on the latest one
            bundle b = MODEL(rhats[lreg,2],trim[lreg],0, qn, qq1, cc, endo,exo,rexo,thresh,strTF)
            if lrprob[lreg]<=alpha			# Only now update using the refinement estimate
                rhats[lreg-1,] = b.rhatCI	# Refinement estimate of 1st threshold value
                lrstats[1:rows(b.lrstat),lreg-1] = b.lrstat # update the 1st threshold estimates
            endif
            beta_indep_T$lreg = b.beta_regindep
            sehet_indep_T$lreg = b.sehet_regindep
            sehomo_indep_T$lreg = b.sehomo_regindep
            beta_dep_T$lreg = b.beta_regdep
            sehet_dep_T$lreg = b.sehet_regdep
            sehomo_dep_T$lreg = b.sehomo_regdep
            DW[lreg+1] = b.dw
            hettest[lreg+1,] = b.hettest
            csdeptest[lreg+1,] = b.csdeptest
            sercorr[lreg+1,] = b.sercorr
            SSE[1+lreg] = b.sse
            R2[1+lreg] = b.r2
            printout(beta_indep_T$lreg, sehet_indep_T$lreg, sehomo_indep_T$lreg, \
              beta_dep_T$lreg, sehet_dep_T$lreg, sehomo_dep_T$lreg, rhats[1:lreg,], \
              SSE[1+lreg], lrtest[lreg], lrcrit[lreg,], lrprob[lreg], nrep, strEXO, \
              strREXO, $lreg, 2, trim[lreg], R2[1+lreg], DW[1+lreg],hettest[lreg+1,], \
              csdeptest[lreg+1,], sercorr[lreg+1,], TF, conf_lev)
        endif
        # Add output to bundle
        OUT.beta_indep_T$lreg = beta_indep_T$lreg
        OUT.sehet_indep_T$lreg = sehet_indep_T$lreg
        OUT.sehomo_indep_T$lreg = sehomo_indep_T$lreg
        OUT.beta_dep_T$lreg = beta_dep_T$lreg
        OUT.sehet_dep_T$lreg = sehet_dep_T$lreg
        OUT.sehomo_dep_T$lreg = sehomo_dep_T$lreg
        OUT.rhats = rhats
    endloop
    # BUNDLE elements for output
    if nthresh==1
        strings Srnam = defarray("Linear Model", "Single Threshold")
        strings Srnam2 = defarray("Single Threshold")
    elif nthresh==2
        strings Srnam = defarray("Linear Model", "Single Threshold", "Dual Threshold")
        strings Srnam2 = defarray("Single Threshold", "Dual Threshold")
    elif nthresh==3
        strings Srnam = defarray("Linear Model", "Single Threshold", "Dual Threshold", "Quad. Threshold")
        strings Srnam2 = defarray("Single Threshold", "Dual Threshold", "Quad. Threshold")
    endif
    strings Scnam2 = defarray("Test stat.", "Prob.")
    rownames(DW,Srnam)
    colnames(DW,"DW")
    OUT.DW = DW
    rownames(hettest,Srnam)
    colnames(hettest,Scnam2)
    OUT.hettest = hettest
    rownames(csdeptest,Srnam)
    colnames(csdeptest,Scnam2)
    OUT.csdeptest = csdeptest
    rownames(sercorr,Srnam)
    colnames(sercorr,Scnam2)
    OUT.sercorr = sercorr
    rownames(lrtest,Srnam2)
    rownames(lrprob,Srnam2)
    rownames(lrcrit,Srnam2)
    colnames(lrcrit,"90pct. 95pct. 99pct.")
    rownames(SSE,Srnam)
    rownames(SSE,Srnam)
    OUT.lrstats = lrstats
    OUT.lrtest = lrtest
    OUT.lrprob = lrprob
    OUT.lrcrit = lrcrit
    OUT.qq = qq1
    OUT.SSE = SSE
    OUT.R2 = R2
    OUT.T = tt
    OUT.N = n
    return OUT
end function

function void lrplot (matrix lrstats "Likelihood ratio (LR) test stats. for threshold.",
      matrix qq "Threshold values evaluated",
      string fname "Path + file name for storing graphs")
    
    # Asymptotic distribution of threshold estimate
    # "No-rejection region' of confidence level 1-alpha
    matrix cc = {6.53, 7.35, 10.59} # 10%, 5 and 1% critical value for H0: gamma=gamma_0

    lrstats = (lrstats .< 1000).*lrstats
    loop nplot=1..cols(lrstats) -q
        matrix mtmp = ones(rows(qq),cols(cc)) .* cc#[nplot,]
        matrix mplot = lrstats[,nplot] ~ mtmp ~ qq
        colnames(mplot, "LR-Ratio 90pct. 95pct. 99pct. qq")
        if fname=="display"
            string fout = fname
        else
            sprintf S2 "@fname/ThresholdPanel_CI_No=%d.png", $nplot
            fout = S2
        endif
        plot mplot
            options with-lines fit=none single-yaxis
            #literal set term png font 'Helvetica,13'
            printf "set title 'Confidence Interval Construction: %d Threshold Model' font 'serif,13'", cols(lrstats)
            printf "set xlabel '%d Threshold Parameter' font 'Helvetica,13'", $nplot
            #literal set ylabel 'Likelihood Ratio' font 'Helvetica,13'
            literal set key outside below font 'Helvetica,13' #top right
            literal set y2tics
            #literal set xtics out offset 0,-0.5			# Move xtics cloer to the x-axis
            literal set ytics out
            #2) put the border more to the background by applying it
            # only on the left and bottom part and put it and the tics in gray
            literal set style line 11 lc rgb "#808080" lt 1
            literal set border 3 back ls 11			# get rid of upper + left border
            literal set tics nomirror
            #add a slight grid to make it easier to follow the exact position of the curves
            literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
            literal set grid back ls 12
            # Line Styles
            literal set for [i=1:5] linetype i dashtype i
            literal set linetype 1 lc rgb "black" lw 2.0	# --- blue
            literal set linetype 2 lc rgb "black" lw 2.0 	# --- red
            literal set linetype 3 lc rgb "black" lw 2.0 	# --- black
            literal set linetype 4 lc rgb "black" lw 2.0	# --- green
        end plot --output="@fout"
    endloop
end function

